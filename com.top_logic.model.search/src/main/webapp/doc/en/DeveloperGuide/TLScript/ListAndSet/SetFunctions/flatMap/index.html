<h2>Syntax</h2>

<p> </p>

<pre>
<code>$collection.flatMap($function)</code></pre>

<h2>Description</h2>

<p>Applies the function <code class="hljs inlineCode">function</code> to each element of the collection <code class="hljs inlineCode">collection</code> and smoothes the results into a single collection. If the function returns a collection for an element, all elements of this collection are added to the result. If the function returns a single value, this value is added directly to the result.</p>

<p>This is equivalent to <code class="hljs inlineCode">collection.map(function).flatten()</code>, but more efficient as no intermediate collections are created.</p>

<h2>Parameters</h2>

<table class="tlDocTable">
	<thead>
		<tr>
			<th>name</th>
			<th>Type</th>
			<th>Type Description</th>
			<th>Mandatory</th>
			<th>Default</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Collection</td>
			<td>Collection</td>
			<td>The input collection whose elements are to be transformed.</td>
			<td>yes</td>
			<td> </td>
		</tr>
		<tr>
			<td>function</td>
			<td>Function</td>
			<td>The function that is applied to each element. The function can return either a collection or a single value.</td>
			<td>yes</td>
			<td> </td>
		</tr>
	</tbody>
</table>

<h2>Return value</h2>

<p><strong>Type:</strong> Collection</p>

<p>A flat collection with the transformed elements.</p>

<h2>Examples</h2>

<h3>Generate multiple values per element</h3>

<pre>
<code>list(1, 2, 3)
    .flatMap(x -&gt; list($x, $x * 10)) </code></pre>

<p><strong>Output:</strong> <code>[1, 10, 2, 20, 3, 30]</code></p>

<p>For each number, both the original number and the 10-fold value are included in the results list.</p>

<h3>Merge lists</h3>

<pre>
<code>list( 
    list("A", "B"), 
    list("C", "D", "E") 
).flatMap(sublist -&gt; $sublist) </code></pre>

<p><strong>Output:</strong> <code>["A", "B", "C", "D", "E"]</code></p>

<p>The nested lists are merged into a flat list.</p>

<h3>Comparison with map().flatten()</h3>

<pre>
<code>// Statt
list(1, 2).map(x -&gt; list($x, $x * 2)).flatten() 
// Besser
list(1, 2).flatMap(x -&gt; list($x, $x * 2)) </code></pre>

<p><strong>Advantage:</strong> The <code>flatMap</code> variant is more efficient, as no temporary list of lists is created.</p>

<p></p>
