/*
 * SPDX-FileCopyrightText: 2022 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package com.top_logic.service.openapi.client.layout;

import static com.top_logic.service.openapi.common.schema.OpenAPISchemaConstants.*;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import com.top_logic.basic.ConfigurationError;
import com.top_logic.basic.StringServices;
import com.top_logic.basic.UnreachableAssertion;
import com.top_logic.basic.col.TupleFactory;
import com.top_logic.basic.config.ConfigurationException;
import com.top_logic.basic.config.InstantiationContext;
import com.top_logic.basic.config.PolymorphicConfiguration;
import com.top_logic.basic.config.TypedConfiguration;
import com.top_logic.basic.config.json.JsonUtilities;
import com.top_logic.basic.util.ResKey;
import com.top_logic.element.meta.TypeSpec;
import com.top_logic.layout.admin.component.TLServiceConfigEditorFormBuilder;
import com.top_logic.layout.form.component.EditComponent;
import com.top_logic.layout.form.model.FormContext;
import com.top_logic.layout.form.values.edit.EditorFactory;
import com.top_logic.mig.html.layout.LayoutComponent;
import com.top_logic.model.search.expr.config.ExprFormat;
import com.top_logic.model.search.expr.config.dom.Expr;
import com.top_logic.model.util.TLModelPartRef;
import com.top_logic.service.openapi.client.authentication.apikey.APIKeyAuthentication;
import com.top_logic.service.openapi.client.authentication.config.ClientAuthentication;
import com.top_logic.service.openapi.client.authentication.config.ClientAuthentications;
import com.top_logic.service.openapi.client.authentication.http.basic.BasicAuthentication;
import com.top_logic.service.openapi.client.authentication.oauth.user.ClientCredentials;
import com.top_logic.service.openapi.client.registry.ServiceMethodRegistry;
import com.top_logic.service.openapi.client.registry.conf.MethodDefinition;
import com.top_logic.service.openapi.client.registry.conf.ParameterDefinition;
import com.top_logic.service.openapi.client.registry.impl.call.CallBuilderFactory;
import com.top_logic.service.openapi.client.registry.impl.call.request.CookieHeaderArgument;
import com.top_logic.service.openapi.client.registry.impl.call.request.HeaderArgument;
import com.top_logic.service.openapi.client.registry.impl.call.request.JSONRequestBody;
import com.top_logic.service.openapi.client.registry.impl.call.request.MultiPartRequestBody;
import com.top_logic.service.openapi.client.registry.impl.call.request.MultiPartRequestBody.MultiPartContent;
import com.top_logic.service.openapi.client.registry.impl.call.request.SimpleHeaderArgument;
import com.top_logic.service.openapi.client.registry.impl.call.uri.PathArgument;
import com.top_logic.service.openapi.client.registry.impl.call.uri.QueryArgument;
import com.top_logic.service.openapi.client.registry.impl.call.uri.SimpleQueryArgument;
import com.top_logic.service.openapi.client.registry.impl.value.ComputedValue;
import com.top_logic.service.openapi.client.registry.impl.value.ConstantValue;
import com.top_logic.service.openapi.client.registry.impl.value.ParameterValue;
import com.top_logic.service.openapi.client.registry.impl.value.ValueProducerFactory;
import com.top_logic.service.openapi.common.OpenAPIConstants;
import com.top_logic.service.openapi.common.authentication.AuthenticationConfig;
import com.top_logic.service.openapi.common.conf.HttpMethod;
import com.top_logic.service.openapi.common.document.ComponentsObject;
import com.top_logic.service.openapi.common.document.IParameterObject;
import com.top_logic.service.openapi.common.document.MediaTypeObject;
import com.top_logic.service.openapi.common.document.OpenapiDocument;
import com.top_logic.service.openapi.common.document.OperationObject;
import com.top_logic.service.openapi.common.document.ParameterObject;
import com.top_logic.service.openapi.common.document.PathItemObject;
import com.top_logic.service.openapi.common.document.ReferencableParameterObject;
import com.top_logic.service.openapi.common.document.RequestBodyObject;
import com.top_logic.service.openapi.common.document.SecuritySchemeObject;
import com.top_logic.service.openapi.common.document.ServerObject;
import com.top_logic.service.openapi.common.layout.ImportOpenAPIConfiguration;
import com.top_logic.service.openapi.common.layout.MultiPartBodyTransferType;
import com.top_logic.service.openapi.common.schema.ArraySchema;
import com.top_logic.service.openapi.common.schema.ObjectSchema;
import com.top_logic.service.openapi.common.schema.PrimitiveSchema;
import com.top_logic.service.openapi.common.schema.Schema;
import com.top_logic.service.openapi.common.schema.SchemaVisitor;
import com.top_logic.tool.boundsec.CommandHandler;

/**
 * {@link CommandHandler} importing an <i>OpenAPI</i> client.
 * 
 * @author <a href="mailto:daniel.busche@top-logic.com">Daniel Busche</a>
 */
public class ImportOpenAPIClient extends ImportOpenAPIConfiguration {

	/**
	 * Workaround type-spec: There is actually no type "base64 encoded bytes", but this information
	 * is needed to transform an input of type {@link TypeSpec#BINARY_TYPE} to a base64 encoded
	 * value.
	 */
	static final String BYTE_TYPE_SPEC = "tl.core:base64EncodedBytes";

	/**
	 * Configuration for the {@link ImportOpenAPIClient}.
	 * 
	 * @author <a href="mailto:daniel.busche@top-logic.com">Daniel Busche</a>
	 */
	public interface Config extends ImportOpenAPIConfiguration.Config {

		// Currently no additional configuration.

	}

	/**
	 * Creates a new {@link ImportOpenAPIClient}.
	 */
	public ImportOpenAPIClient(InstantiationContext context, Config config) {
		super(context, config);
	}

	@Override
	protected void applyConfig(OpenapiDocument config, LayoutComponent component, Object model, List<ResKey> warnings) {
		EditComponent editor = (EditComponent) component;

		FormContext formContext = editor.getFormContext();
		TLServiceConfigEditorFormBuilder.EditModel m =
			(TLServiceConfigEditorFormBuilder.EditModel) EditorFactory.getModel(formContext);
		ServiceMethodRegistry.Config<?> serviceConfiguration =
			(ServiceMethodRegistry.Config<?>) m.getServiceConfiguration();

		addAuthentications(config, serviceConfiguration, warnings);
		addMethods(config, serviceConfiguration, warnings);
	}

	/**
	 * Creates (and adds) {@link AuthenticationConfig}'s based on the given {@link OpenapiDocument}.
	 * 
	 * @param openAPI
	 *        <i>OpenAPI</i> specification.
	 * @param auth
	 *        {@link ClientAuthentications} to enhance.
	 * @param warnings
	 *        Log to add potential warnings to.
	 */
	private void addAuthentications(OpenapiDocument openAPI, ClientAuthentications auth, List<ResKey> warnings) {
		Map<String, ClientAuthentication.Config<?>> authentications = auth.getAuthentications();
		ComponentsObject components = openAPI.getComponents();
		if (components != null) {
			Map<String, SecuritySchemeObject> securitySchemes = components.getSecuritySchemes();
			for (SecuritySchemeObject schema : securitySchemes.values()) {
				ClientAuthentication.Config<?> authentication = createAuthentication(schema, warnings);
				if (authentication != null) {
					authentication.setDomain(schema.getSchemaName());
					authentications.put(authentication.getDomain(), authentication);
				}
			}
		}
	}

	private ClientAuthentication.Config<?> createAuthentication(SecuritySchemeObject value, List<ResKey> warnings) {
		switch (value.getType()) {
			case API_KEY:
				return createAPIKeyAuthentication(APIKeyAuthentication.Config.class, value);
			case HTTP:
				return createHTTPAuthentication(BasicAuthentication.Config.class, value, warnings);
			case OAUTH2:
				return createOAuth2Authentication(ClientCredentials.Config.class, value, warnings);
			case OPEN_ID_CONNECT:
				return createOpenIDConnectAuthentication(ClientCredentials.Config.class, value);
			default:
				throw new UnreachableAssertion("Unexpected SecuritySchemeType: " + value.getType());
		}

	}

	private void addMethods(OpenapiDocument config, ServiceMethodRegistry.Config<?> serviceConfiguration,
			List<ResKey> warnings) {
		String globalURL = findGlobalURL(config);
		for (PathItemObject path : config.getPaths().values()) {
			String pathName = synthesizeMethodName(path);
			String localURL = firstServerURL(path.getServers());
			String url = localURL != null ? localURL : globalURL;
			Map<String, MethodDefinition> methods = serviceConfiguration.getMethodDefinitions();

			createMethod(methods, config, path.getGet(), HttpMethod.GET, pathName, url, path, warnings);
			createMethod(methods, config, path.getPut(), HttpMethod.PUT, pathName, url, path, warnings);
			createMethod(methods, config, path.getPost(), HttpMethod.POST, pathName, url, path, warnings);
			createMethod(methods, config, path.getDelete(), HttpMethod.DELETE, pathName, url, path, warnings);
			createMethod(methods, config, path.getOptions(), HttpMethod.OPTIONS, pathName, url, path, warnings);
			createMethod(methods, config, path.getHead(), HttpMethod.HEAD, pathName, url, path, warnings);
			createMethod(methods, config, path.getPatch(), HttpMethod.PATCH, pathName, url, path, warnings);
			createMethod(methods, config, path.getTrace(), HttpMethod.TRACE, pathName, url, path, warnings);
		}
	}

	private void createMethod(Map<String, MethodDefinition> methods, OpenapiDocument completeAPI,
			OperationObject operation, HttpMethod httpMethod, String baseName, String url, PathItemObject path,
			List<ResKey> warnings) {
		if (operation == null) {
			return;
		}

		MethodDefinition newMethod = TypedConfiguration.newConfigItem(MethodDefinition.class);
		newMethod.setName(getMethodName(operation, httpMethod, baseName));
		newMethod.setBaseUrl(url);
		String description = operation.getDescription();
		if (description != null && !description.isBlank()) {
			newMethod.setDescription(description);
		} else {
			String summary = operation.getSummary();
			if (summary != null && !summary.isBlank()) {
				newMethod.setDescription(summary);
			}
		}
		newMethod.setHttpMethod(httpMethod);
		addParameters(newMethod, completeAPI, operation, path, warnings);
		addSecurity(newMethod, completeAPI, operation);
		methods.put(newMethod.getName(), newMethod);
	}

	private void addParameters(MethodDefinition newMethod, OpenapiDocument completeAPI, OperationObject operation,
			PathItemObject path, List<ResKey> warnings) {
		Pattern paramNamePattern = Pattern.compile(ParameterDefinition.NAME_PATTERN);
		Set<String> parameterNames = new HashSet<>();
		for (ParameterObject parameter : mergeParameters(completeAPI, path, operation, warnings)) {
			String requiredParameterName = getParameterName(parameter);
			String parameterName = toValidParamName(paramNamePattern, requiredParameterName);

			boolean newName = parameterNames.add(parameterName);
			if (!newName) {
				String clashingName = parameterName;
				int nameIDX = 1;
				do {
					parameterName = clashingName + nameIDX;
					if (parameterNames.add(parameterName)) {
						break;
					}
					nameIDX++;
				} while (true);
			}

			ParameterDefinition paramDef = createParameter(parameterName, parameter, warnings, completeAPI);
			boolean encodeBase64 = false;
			if (hasByteTypeWorkaround(paramDef)) {
				encodeBase64 = true;
				replaceByteTypeWorkaround(paramDef);
			}
			newMethod.getParameters().add(paramDef);

			switch (parameter.getIn()) {
				case COOKIE:
					CookieHeaderArgument.Config<?> cookieArgument;
					if (requiredParameterName != parameterName || encodeBase64) {
						cookieArgument = newConfigForImplementation(CookieHeaderArgument.class);
						cookieArgument.setValue(newParameterValue(parameterName, encodeBase64));
					} else {
						cookieArgument = newConfigForImplementation(CookieHeaderArgument.class);
					}
					cookieArgument.setName(requiredParameterName);
					newMethod.getCallBuilders().add(cookieArgument);
					break;
				case HEADER:
					HeaderArgument.Config<?> headerArgument;
					if (requiredParameterName != parameterName || encodeBase64) {
						headerArgument = newConfigForImplementation(HeaderArgument.class);
						headerArgument.setValue(newParameterValue(parameterName, encodeBase64));
					} else {
						headerArgument = newConfigForImplementation(SimpleHeaderArgument.class);
					}
					headerArgument.setName(requiredParameterName);
					newMethod.getCallBuilders().add(headerArgument);
					break;
				case PATH:
					// Path parameters are processed later
					break;
				case QUERY:
					QueryArgument.Config<?> queryArgument;
					if (requiredParameterName != parameterName || encodeBase64) {
						queryArgument = newConfigForImplementation(QueryArgument.class);
						queryArgument.setValue(newParameterValue(parameterName, encodeBase64));
					} else {
						queryArgument = newConfigForImplementation(SimpleQueryArgument.class);
					}
					queryArgument.setName(requiredParameterName);
					newMethod.getCallBuilders().add(queryArgument);
					break;
			}
		}
		if (newMethod.getHttpMethod().supportsBody()) {
			RequestBodyObject requestBody = operation.getRequestBody();
			if (requestBody != null) {
				processBody(newMethod, warnings, parameterNames, requestBody, completeAPI);
			}
		} else {
			// Body is either not allowed or behaviour is undefined. In this case a consumer
			// SHALL ignore it.
		}

		handlePathParameters(newMethod, path.getPath());
	}

	private void processBody(MethodDefinition newMethod, List<ResKey> warnings, Set<String> parameterNames,
			RequestBodyObject requestBody, OpenapiDocument completeAPI) {
		Collection<MediaTypeObject> possibleBodyTypes = requestBody.getContent().values();
		for (MediaTypeObject mediaObject : possibleBodyTypes) {
			String mediaType = mediaObject.getMediaType();
			switch (mediaType) {
				case OpenAPIConstants.MULTIPART_FORM_DATA_CONTENT_TYPE: {
					MultiPartRequestBody.Config bodyParameter =
						addMultiPartBody(newMethod, warnings, parameterNames, requestBody, mediaObject, completeAPI);
					if (bodyParameter != null) {
						bodyParameter.setTransferType(MultiPartBodyTransferType.FORM_DATA);
					}
					return;
				}
				case OpenAPIConstants.APPLICATION_URL_ENCODED_CONTENT_TYPE: {
					MultiPartRequestBody.Config bodyParameter =
						addMultiPartBody(newMethod, warnings, parameterNames, requestBody, mediaObject, completeAPI);
					if (bodyParameter != null) {
						bodyParameter.setTransferType(MultiPartBodyTransferType.URL_ENCODED);
					}
					return;
				}
				case JsonUtilities.JSON_CONTENT_TYPE: {
					addJSONBody(newMethod, warnings, parameterNames, requestBody, mediaObject, completeAPI);
					return;
				}
				default:
					continue;
			}
		}

		/* Actually unsupported. Use "first" body. */
		addJSONBody(newMethod, warnings, parameterNames, requestBody, possibleBodyTypes.iterator().next(), completeAPI);
	}

	private MultiPartRequestBody.Config addMultiPartBody(MethodDefinition newMethod, List<ResKey> warnings,
			Set<String> parameterNames, RequestBodyObject requestBody, MediaTypeObject mediaObject,
			OpenapiDocument completeAPI) {
		String schema = mediaObject.getSchema();
		List<ParameterDefinition> newParams;
		if (schema.isEmpty()) {
			ParameterDefinition paramDef =
				defaultBodyParameter(schema, warnings, parameterNames, requestBody, completeAPI);
			newParams = Collections.singletonList(paramDef);
		} else {
			Schema parsedSchema = parseSchema(schema, "requestBody", globalSchemas(completeAPI), warnings);
			if (parsedSchema == null) {
				ParameterDefinition paramDef =
					defaultBodyParameter(schema, warnings, parameterNames, requestBody, completeAPI);
				newParams = Collections.singletonList(paramDef);
			} else if (parsedSchema instanceof ObjectSchema) {
				newParams = ((ObjectSchema) parsedSchema).getProperties().stream().map(property -> {
					Schema propSchema = property.getSchema();
					String description = propSchema != null ? propSchema.getDescription() : null;
					return createParameter(property.getName(), description, property.isRequired(), propSchema,
						warnings);
				}).collect(Collectors.toList());
			} else {
				warnings.add(I18NConstants.UNEXPECTED_SCHEMA_FOR_MULTIPART_BODY__METHOD.fill(newMethod.getName()));
				return null;
			}
		}
		
		MultiPartRequestBody.Config bodyArgument = newConfigForImplementation(MultiPartRequestBody.class);
		for (ParameterDefinition param : newParams) {
			String parameterName = param.getName();
			MultiPartContent part = TypedConfiguration.newConfigItem(MultiPartContent.class);
			part.setName(parameterName);
			if (hasByteTypeWorkaround(param)) {
				replaceByteTypeWorkaround(param);
				part.setContent(newVariableBase64Encoded(parameterName));
			} else {
				part.setContent(newVariable(parameterName));
			}
			bodyArgument.getParts().add(part);
		}
		newMethod.getParameters().addAll(newParams);
		newMethod.getCallBuilders().add(bodyArgument);
		return bodyArgument;
	}

	private static Expr newVariable(String variableName) {
		Expr.Var variable = TypedConfiguration.newConfigItem(Expr.Var.class);
		variable.setName(variableName);
		return variable;
	}

	private static Expr newVariableBase64Encoded(String variableName) {
		return parseExpr("$" + variableName + ".base64Encode()");
	}

	private static Expr parseExpr(String expression) {
		try {
			return ExprFormat.INSTANCE.getValue(ImportOpenAPIClient.class.getSimpleName() + "#parseExpr", expression);
		} catch (ConfigurationException ex) {
			throw new ConfigurationError(ex);
		}
	}

	private void addJSONBody(MethodDefinition newMethod, List<ResKey> warnings, Set<String> parameterNames,
			RequestBodyObject requestBody, MediaTypeObject mediaObject, OpenapiDocument completeAPI) {
		String schema = mediaObject.getSchema();
		ParameterDefinition paramDef = defaultBodyParameter(schema, warnings, parameterNames, requestBody, completeAPI);
		boolean encodeBase64 = false;
		if (hasByteTypeWorkaround(paramDef)) {
			replaceByteTypeWorkaround(paramDef);
			encodeBase64 = true;
		}
		newMethod.getParameters().add(paramDef);
		JSONRequestBody.Config<?> bodyArgument = newConfigForImplementation(JSONRequestBody.class);
		if (encodeBase64) {
			bodyArgument.setJson(newVariableBase64Encoded(paramDef.getName()));
		} else {
			bodyArgument.setJson(newVariable(paramDef.getName()));
		}
		newMethod.getCallBuilders().add(bodyArgument);
	}

	/**
	 * Replaces the workaround "base64 encoded bytes" type in the given parameter by the
	 * {@link TypeSpec#BINARY_TYPE}.
	 * 
	 * @see #hasByteTypeWorkaround(ParameterDefinition)
	 */
	private void replaceByteTypeWorkaround(ParameterDefinition paramDef) {
		paramDef.setType(TLModelPartRef.ref(TypeSpec.BINARY_TYPE));
	}

	/**
	 * Checks whether the parameter contains the workaround "base64 encoded bytes" type.
	 * 
	 * @see #replaceByteTypeWorkaround(ParameterDefinition)
	 */
	private boolean hasByteTypeWorkaround(ParameterDefinition paramDef) {
		TLModelPartRef type = paramDef.getType();
		if (type == null) {
			return false;
		}
		return BYTE_TYPE_SPEC.equals(type.qualifiedName());
	}

	private ParameterDefinition defaultBodyParameter(String schema, List<ResKey> warnings, Set<String> parameterNames,
			RequestBodyObject requestBody, OpenapiDocument completeAPI) {
		String description = requestBody.getDescription();
		return createParameter(requestBodyParameterName(parameterNames), description, requestBody.isRequired(), schema,
			warnings, completeAPI);
	}

	/**
	 * @param paramNamePattern
	 *        Compiled Pattern fetched from {@link ParameterDefinition#NAME_PATTERN}.
	 */
	private String toValidParamName(Pattern paramNamePattern, String origParameterName) {
		Matcher matcher = paramNamePattern.matcher(origParameterName);
		if (matcher.matches()) {
			return origParameterName;
		}
		if (origParameterName.length() == 0) {
			return "param";
		}
		StringBuilder newName = new StringBuilder();
		int index = 0;
		char firstChar = origParameterName.charAt(index);
		if (!('A' <= firstChar && firstChar <= 'Z') && !('a' <= firstChar && firstChar <= 'z')) {
			newName.append("p_");
		}
		do {
			char c = origParameterName.charAt(index++);
			if ('a' <= c && c <= 'z') {
				newName.append(c);
				continue;
			}
			if ('A' <= c && c <= 'Z') {
				newName.append(c);
				continue;
			}
			if ('0' <= c && c <= '9') {
				newName.append(c);
				continue;
			}
			if ('_' == c) {
				newName.append(c);
				continue;
			}
			newName.append('_');
		} while (index < origParameterName.length());

		return newName.toString();
	}

	private PolymorphicConfiguration<? extends ValueProducerFactory> newParameterValue(String name,
			boolean encodeBase64) {
		ParameterValue.Config<?> param = newConfigForImplementation(ParameterValue.class);
		param.setParameter(name);
		if (!encodeBase64) {
			return param;
		} else {
			ComputedValue.Config<?> result = newConfigForImplementation(ComputedValue.class);
			result.getArguments().add(param);
			result.setFunction(parseExpr("param -> $param.base64Encode()"));
			return result;
		}
	}

	private String requestBodyParameterName(Set<String> parameterNames) {
		String baseName = "body";
		if (parameterNames.contains(baseName)) {
			int i = 1;
			while (i < Integer.MAX_VALUE) {
				String requestBodyParamName = baseName + i;
				if (!parameterNames.contains(requestBodyParamName)) {
					return requestBodyParamName;
				}
				i++;
			}
			throw new IllegalArgumentException("Unable to determine parameter name for request body.");
		} else {
			return baseName;
		}
	}

	private void addSecurity(MethodDefinition newMethod, OpenapiDocument completeAPI, OperationObject operation) {
		Map<String, List<String>> securityConfig;
		List<Map<String, List<String>>> localSecurities = operation.getSecurity();
		if (localSecurities.isEmpty()) {
			if (operation.valueSet(operation.descriptor().getProperty(OperationObject.SECURITY))) {
				// Empty security array is set explicitly => security was removed;
				return;
			}
			List<Map<String, List<String>>> globalSecurities = completeAPI.getSecurity();
			if (globalSecurities.isEmpty()) {
				// No security at all.
				return;
			}
			securityConfig = globalSecurities.get(0);
		} else {
			securityConfig = localSecurities.get(0);
		}
		newMethod.setAuthentication(new ArrayList<>(securityConfig.keySet()));
	}

	private void handlePathParameters(MethodDefinition newMethod, String path) {
		List<PolymorphicConfiguration<? extends CallBuilderFactory>> pathConfigs = new ArrayList<>();
		String[] parts = path.split("/");
		for (String pathPart : parts) {
			if (pathPart.isEmpty()) {
				continue;
			}
			PolymorphicConfiguration<? extends ValueProducerFactory> value;
			if (pathPart.startsWith("{") && pathPart.endsWith("}")) {
				ParameterValue.Config<?> paramValue = newConfigForImplementation(ParameterValue.class);
				String paramName = pathPart.substring(1, pathPart.length() - 1);
				paramValue.setParameter(paramName);
				value = paramValue;
			} else {
				ConstantValue.Config<?> constantValue = newConfigForImplementation(ConstantValue.class);
				constantValue.setValue(pathPart);
				value = constantValue;
			}
			PathArgument.Config<?> pathArgument = newConfigForImplementation(PathArgument.class);
			pathArgument.setValue(value);
			pathConfigs.add(pathArgument);
		}
		newMethod.getCallBuilders().addAll(0, pathConfigs);
	}

	private Collection<ParameterObject> mergeParameters(OpenapiDocument completeAPI, PathItemObject path,
			OperationObject operation, List<ResKey> warnings) {
		List<IParameterObject> pathParams = path.getParameters();
		List<IParameterObject> operationParams = operation.getParameters();
		Map<String, ReferencableParameterObject> globalParameters = globalParameters(completeAPI);
		LinkedHashMap<Object, ParameterObject> tmp = new LinkedHashMap<>();
		for (IParameterObject param : pathParams) {
			ParameterObject paramObj = resolveParameterObject(param, globalParameters, warnings);
			if (paramObj != null) {
				tmp.put(uniqueIdentifier(paramObj), paramObj);
			}
		}
		/* Local parameters may override global parameters. */
		for (IParameterObject param : operationParams) {
			ParameterObject paramObj = resolveParameterObject(param, globalParameters, warnings);
			if (paramObj != null) {
				tmp.put(uniqueIdentifier(paramObj), paramObj);
			}
		}
		return tmp.values();
	}

	private ParameterDefinition createParameter(String parameterName, ParameterObject parameter,
			List<ResKey> warnings, OpenapiDocument completeAPI) {
		return createParameter(parameterName, parameter.getDescription(), parameter.isRequired(), parameter.getSchema(),
			warnings, completeAPI);
	}

	private String getParameterName(ParameterObject parameter) {
		return parameter.getName();
	}

	private ParameterDefinition createParameter(String paramName, String description, boolean isRequired,
			String schema, List<ResKey> warnings, OpenapiDocument completeAPI) {
		Schema schemaObject;
		if (!StringServices.isEmpty(schema)) {
			schemaObject = parseSchema(schema, paramName, globalSchemas(completeAPI), warnings);
		} else {
			schemaObject = null;
		}
		return createParameter(paramName, description, isRequired, schemaObject, warnings);
	}

	private ParameterDefinition createParameter(String paramName, String description, boolean isRequired,
			Schema schemaObject, List<ResKey> warnings) {
		ParameterDefinition newParameterDef = TypedConfiguration.newConfigItem(ParameterDefinition.class);
		newParameterDef.setName(paramName);
		newParameterDef.setRequired(isRequired);
		if (description != null && !description.isBlank()) {
			newParameterDef.setDescription(description);
		}
		if (schemaObject != null) {
			ResKey problem = schemaObject.visit(applySchema(), newParameterDef);
			if (problem != ResKey.NONE) {
				warnings.add(I18NConstants.UNSUPPORTED_PARAMETER_TYPE__PARAMETER__TYPE.fill(newParameterDef.getName(),
					schemaObject.getType()));
			}
		}

		return newParameterDef;
	}

	private SchemaVisitor<ResKey, ParameterDefinition> applySchema() {
		return new SchemaVisitor<>() {

			@Override
			public ResKey visitPrimitiveSchema(PrimitiveSchema schema, ParameterDefinition newParameterDef) {
				String typespec;
				String typeFormat = schema.getFormat();
				switch (schema.getType()) {
					case SCHEMA_TYPE_STRING:
						switch (typeFormat) {
							case SCHEMA_FORMAT_DATE:
								typespec = TypeSpec.DATE_TYPE;
								break;
							case SCHEMA_FORMAT_DATE_TIME:
								typespec = TypeSpec.DATE_TIME_TYPE;
								break;
							case SCHEMA_FORMAT_BYTE:
								typespec = BYTE_TYPE_SPEC;
								break;
							case SCHEMA_FORMAT_BINARY:
								typespec = TypeSpec.BINARY_TYPE;
								break;
							case StringServices.EMPTY_STRING:
								typespec = TypeSpec.STRING_TYPE;
								break;
							default:
								typespec = TypeSpec.STRING_TYPE;
								break;
						}
						break;
					case SCHEMA_TYPE_NUMBER:
						switch (typeFormat) {
							case SCHEMA_FORMAT_FLOAT:
								typespec = TypeSpec.FLOAT_TYPE;
								break;
							case SCHEMA_FORMAT_DOUBLE:
								typespec = TypeSpec.DOUBLE_TYPE;
								break;
							case StringServices.EMPTY_STRING:
								typespec = TypeSpec.FLOAT_TYPE;
								break;
							default:
								typespec = TypeSpec.FLOAT_TYPE;
								break;
						}
						break;
					case SCHEMA_TYPE_INTEGER:
						switch (typeFormat) {
							case SCHEMA_FORMAT_INT32:
								typespec = TypeSpec.INTEGER_TYPE;
								break;
							case SCHEMA_FORMAT_INT64:
								typespec = TypeSpec.LONG_TYPE;
								break;
							case StringServices.EMPTY_STRING:
								typespec = TypeSpec.INTEGER_TYPE;
								break;
							default:
								typespec = TypeSpec.INTEGER_TYPE;
								break;
						}
						break;
					case SCHEMA_TYPE_BOOLEAN:
						typespec = TypeSpec.BOOLEAN_TYPE;
						break;
					default:
						return I18NConstants.UNSUPPORTED_PARAMETER_TYPE__PARAMETER__TYPE.fill(newParameterDef.getName(),
							schema.getType());
				}
				newParameterDef.setType(TLModelPartRef.ref(typespec));
				addDefaultValue(schema, newParameterDef);
				addDescription(schema, newParameterDef);
				return ResKey.NONE;
			}

			@Override
			public ResKey visitObjectSchema(ObjectSchema schema, ParameterDefinition newParameterDef) {
				newParameterDef.setType(TLModelPartRef.ref(TypeSpec.JSON_TYPE));
				addDefaultValue(schema, newParameterDef);
				addDescription(schema, newParameterDef);
				return ResKey.NONE;
			}

			@Override
			public ResKey visitArraySchema(ArraySchema schema, ParameterDefinition newParameterDef) {
				newParameterDef.setMultiple(true);
				addDescription(schema, newParameterDef);
				return schema.getItems().visit(this, newParameterDef);
			}

			private void addDescription(Schema s, ParameterDefinition param) {
				String description = s.getDescription();
				if (description == null) {
					return;
				}
				param.setDescription(description);
			}

			private void addDefaultValue(Schema s, ParameterDefinition param) {
				String defaultValue = s.getDefault();
				if (defaultValue == null) {
					return;
				}
				Expr defaultExpr;
				try {
					defaultExpr = ExprFormat.INSTANCE.getValue(ParameterDefinition.DEFAULT_VALUE, defaultValue);
				} catch (ConfigurationException ex) {
					throw new ConfigurationError(ex);
				}
				param.setDefaultValue(defaultExpr);
			}
		};
	}
	private String getMethodName(OperationObject operation, HttpMethod httpMethod, String baseName) {
		String operationId = operation.getOperationId();
		if (!operationId.isEmpty()) {
			return operationId;
		}
		switch (httpMethod) {
			case DELETE:
				return "delete_" + baseName;
			case GET:
				return "get_" + baseName;
			case HEAD:
				return "head_" + baseName;
			case OPTIONS:
				return "options_" + baseName;
			case PATCH:
				return "patch_" + baseName;
			case POST:
				return "post_" + baseName;
			case PUT:
				return "put_" + baseName;
			case TRACE:
				return "trace_" + baseName;
			default:
				throw new UnreachableAssertion("Unknown method: " + httpMethod);

		}
	}

	private String findGlobalURL(OpenapiDocument config) {
		String firstServerURL = firstServerURL(config.getServers());
		if (firstServerURL != null) {
			return firstServerURL;
		}
		/* When no servers object is given; the URL is "/" as defined in OpenAPI Specification */
		return "/";
	}

	private String firstServerURL(List<ServerObject> servers) {
		if (servers.size() == 0) {
			return null;
		}
		return servers.iterator().next().getUrl();
	}

	private String synthesizeMethodName(PathItemObject item) {
		String path = item.getPath();
		char replacement = '_';

		StringBuilder name = new StringBuilder();
		boolean lastCharReplaced = false;
		for (int index = 0; index < path.length(); index++) {
			char c = path.charAt(index);
			if (isIllegalChar(c)) {
				if (name.length() == 0) {
					// no replacement at begin.
				} else if (lastCharReplaced) {
					// no duplicate replacement.
				} else {
					name.append(replacement);
					lastCharReplaced = true;
				}
			} else {
				name.append(c);
				lastCharReplaced = false;
			}
		}
		if (lastCharReplaced) {
			name.setLength(name.length() - 1);
		}
		return name.toString();
	}

	private boolean isIllegalChar(char c) {
		return c == '/' || c == '\\' || c == '{' || c == '}';
	}

	private Object uniqueIdentifier(ParameterObject param) {
		return new TupleFactory.Pair<>(getParameterName(param), param.getIn());
	}

}
