/*
 * SPDX-FileCopyrightText: 2025 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package com.top_logic.element.changelog.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import com.google.common.base.Functions;

import com.top_logic.basic.CollectionUtil;
import com.top_logic.basic.col.diff.CollectionDiff;
import com.top_logic.basic.col.diff.SetDiff;
import com.top_logic.basic.col.diff.op.DiffOp;
import com.top_logic.basic.col.diff.op.DiffOp.Visitor;
import com.top_logic.basic.shared.collection.CollectionUtilShared;
import com.top_logic.basic.util.ResKey;
import com.top_logic.element.changelog.model.trans.TransientChangeSet;
import com.top_logic.element.changelog.model.trans.TransientCreation;
import com.top_logic.element.changelog.model.trans.TransientDeletion;
import com.top_logic.element.changelog.model.trans.TransientModification;
import com.top_logic.element.changelog.model.trans.TransientUpdate;
import com.top_logic.knowledge.objects.identifier.ObjectReference;
import com.top_logic.knowledge.service.KBUtils;
import com.top_logic.knowledge.wrap.WrapperHistoryUtils;
import com.top_logic.layout.provider.MetaLabelProvider;
import com.top_logic.model.ModelKind;
import com.top_logic.model.TLClass;
import com.top_logic.model.TLObject;
import com.top_logic.model.TLReference;
import com.top_logic.model.TLStructuredTypePart;
import com.top_logic.model.factory.TLFactory;
import com.top_logic.util.model.ModelService;

/**
 * Interface for {@link #CHANGE_SET_TYPE} business objects.
 * 
 * @author Automatically generated by {@link com.top_logic.element.model.generate.InterfaceTemplateGenerator}
 */
public interface ChangeSet extends com.top_logic.element.changelog.model.impl.ChangeSetBase {

	/**
	 * Inverts this {@link ChangeSet}.
	 */
	default TransientChangeSet revert() {
		TransientChangeSet undo = new TransientChangeSet();
		undo.setRevision(getParentRev());
		undo.setParentRev(getRevision());
		undo.setAuthor(getAuthor());
		undo.setDate(getDate());
		undo.setMessage(revert(getMessage()));

		for (Change change : getChanges()) {
			if (change instanceof Creation creation) {
				TransientDeletion delete = new TransientDeletion();
				delete.setObject(creation.getObject());
				delete.setImplicit(creation.getImplicit());
				undo.addChange(delete);
			} else if (change instanceof Deletion deletion) {
				TransientCreation create = new TransientCreation();
				create.setObject(deletion.getObject());
				create.setImplicit(deletion.getImplicit());
				undo.addChange(create);
			} else if (change instanceof Update update) {
				TransientUpdate revert = new TransientUpdate();
				revert.setObject(update.getOldObject());
				revert.setOldObject(update.getObject());
				for (Modification modification : update.getModifications()) {
					TransientModification restore = new TransientModification();
					restore.setPart(modification.getPart());
					restore.setNewValue(modification.getOldValue());
					restore.setOldValue(modification.getNewValue());
					revert.addModification(restore);
				}
				undo.addChange(revert);
			}
		}

		return undo;
	}

	/**
	 * Applies the changes recorded in this change set to the current version of the model.
	 * 
	 * @return A list of problems that were detected during execution.
	 */
	default List<ResKey> apply() {
		TLFactory factory = ModelService.getInstance().getFactory();

		List<ResKey> problems = new ArrayList<>();
		Map<TLObject, TLObject> created = new HashMap<>();

		// First process creations, since the created objects might be used in further updates.
		for (Change change : getChanges()) {
			if (change instanceof Creation creation) {
				TLObject template = creation.getObject();
				TLObject currentTemplate = WrapperHistoryUtils.getCurrent(template);
				if (currentTemplate != null) {
					problems.add(I18NConstants.PROBLEM_OBJECT_TO_CREATE_ALREADY_EXISTS__OBJ
						.fill(MetaLabelProvider.INSTANCE.getLabel(currentTemplate)));
					continue;
				}
				TLClass templateType = (TLClass) template.tType();
				if (!WrapperHistoryUtils.isCurrent(templateType)) {
					/* The type does not longer exists. Otherwise the type would be a current
					 * element (the type of an object is always current). */
					problems.add(I18NConstants.PROBLEM_TYPE_FOR_OBJECT_TO_CREATE_NO_LONGE_EXISTS__OBJ_TYPE.fill(
						MetaLabelProvider.INSTANCE.getLabel(template),
						MetaLabelProvider.INSTANCE.getLabel(templateType)));
					continue;
				}

				TLObject revived = factory.createObject(templateType, null, null, template.tIdLocal());
				created.put(revived, template);
			}
		}

		// Set values to properties of created objects.
		long rev = getRevision().getCommitNumber();
		long parentRev = getParentRev().getCommitNumber();
		for (Entry<TLObject, TLObject> create : created.entrySet()) {
			TLObject revived = create.getKey();
			TLObject template = create.getValue();

			for (TLStructuredTypePart part : revived.tType().getAllParts()) {
				if (part.isDerived()) {
					continue;
				}

				Object newValue = resolveNewValue(problems, rev, part, template, revived);

				revived.tUpdate(part, newValue);
			}
		}

		// Process deletions. Deletions must be processed before property updates, since property
		// updates may synthesize additional deletions, if values in composition references are
		// replaced. When processing recorded deletions in advance, those regular deletions are not
		// detected as merge conflicts.
		for (Change change : getChanges()) {
			if (change instanceof Deletion deletion) {
				TLObject deleted = deletion.getObject();
				TLObject toDelete = WrapperHistoryUtils.getCurrent(deleted);
				if (toDelete == null) {
					continue;
				}

				for (TLStructuredTypePart part : toDelete.tType().getAllParts()) {
					if (part.getModelKind() == ModelKind.REFERENCE) {
						TLReference reference = (TLReference) part;

						if (reference.isComposite()) {
							Map<ObjectReference, TLObject> newCompositeParts =
								CollectionUtilShared.asCollection(toDelete.tValue(reference))
									.stream()
									.map(TLObject.class::cast)
									.collect(
										Collectors.toMap(WrapperHistoryUtils::getUnversionedIdentity,
											Functions.identity()));
							CollectionUtilShared.asCollection(deleted.tValue(reference))
								.stream()
								.map(TLObject.class::cast)
								.map(WrapperHistoryUtils::getUnversionedIdentity)
								.forEach(newCompositeParts.keySet()::remove);
							/* Clear composition references to make sure that only those objects are
							 * deleted that are requested to delete. */
							toDelete.tUpdate(reference, null);
							/* Delete additional composite parts that were not referenced at
							 * deletion time to simulate automatic deletion of referenced objects.
							 * Objects that were referenced at deletion time should have an own
							 * deletion entry in the change set. */
							KBUtils.deleteAll(newCompositeParts.values());
						}
					}
				}

				toDelete.tDelete();
			}
		}

		// Process updates.
		for (Change change : getChanges()) {
			if (change instanceof Update update) {
				// The object that represents the result of the change to perform.
				TLObject template = update.getObject();

				// The current object on which to re-do the change.
				TLObject target = WrapperHistoryUtils.getCurrent(template);
				if (target == null) {
					problems.add(I18NConstants.PROBLEM_OBJECT_TO_MODIFY_NO_LONGER_EXISTS__OBJ
						.fill(MetaLabelProvider.INSTANCE.getLabel(template)));
					continue;
				}

				// The base object on which the change was initially performed.
				TLObject oldBaseObject = update.getOldObject();

				for (Modification modification : update.getModifications()) {
					TLStructuredTypePart part = modification.getPart();

					// The original value that was set before the original change.
					Object oldBaseValue = oldBaseObject.tValue(part);

					// The original value transformed to the current time frame.
					Object baseValue = toCurrent(parentRev, part, oldBaseValue);

					// The current value of the property that will be changed.
					Object currentValue = target.tValue(part);

					// The value that is now set during re-do.
					Object newValue = resolveNewValue(problems, rev, part, template, target);

					Object newValueMerged;
					if (!Objects.equals(currentValue, baseValue)) {
						// There is a merge conflict, since the original value changed.
						
						// Original change  Replay change   New change
						//  parentRev,rev       head           head
						//                  
						// oldBaseValue       baseValue     currentValue
						//       |                |             |
						//       v                v             v
						// templateValue       newValue    newValueMerged

						// The since currentValue differs from baseValue, the patch/difference
						// baseValue -> newValue must be applied to currentValue.

						// However, this approach is only reasonable for a property containing
						// multiple values.
						if (part.isMultiple()) {
							if (part.isOrdered() || part.isBag()) {
								List<?> left = CollectionUtil.asList(baseValue);
								List<?> right = CollectionUtil.asList(newValue);
								List<DiffOp<Object>> listDiff = CollectionDiff.diffList(x -> x, left, right);
								
								Visitor<? super Object, Void, List<Object>> apply = part.isBag()
									? ApplyListDiff.getInstanceBag()
									: ApplyListDiff.getInstance();
								List<Object> merged = new ArrayList<>(CollectionUtil.asList(currentValue));
								for (DiffOp<Object> diff : listDiff) {
									diff.visit(apply, merged);
								}

								newValueMerged = merged;
							} else {
								Collection<?> left = CollectionUtil.asSet(baseValue);
								Collection<?> right = CollectionUtil.asSet(newValue);
								SetDiff<Object> setDiff = CollectionDiff.diffSet(x -> x, left, right);

								Set<Object> merged = new HashSet<>(CollectionUtil.asSet(currentValue));
								merged.removeAll(setDiff.getDeleted());
								merged.addAll(setDiff.getCreated());
								newValueMerged = merged;
							}
						} else {
							// Overwrite as only option.
							newValueMerged = newValue;
						}

						problems.add(I18NConstants.PROBLEM_VALUE_CHANGED_IN_BETWEEN__OBJ_PART_ORIG_CURR_MERGED
							.fill(MetaLabelProvider.INSTANCE.getLabel(target),
								MetaLabelProvider.INSTANCE.getLabel(part),
								MetaLabelProvider.INSTANCE.getLabel(baseValue),
								MetaLabelProvider.INSTANCE.getLabel(currentValue),
								MetaLabelProvider.INSTANCE.getLabel(newValueMerged)));
					} else {
						// No conflict.
						newValueMerged = newValue;
					}

					target.tUpdate(part, newValueMerged);
				}
			}
		}
		return problems;
	}

	private Object resolveNewValue(List<ResKey> problems, long rev, TLStructuredTypePart part, TLObject template,
			TLObject target) {
		// The value that was set in the original update.
		Object templateValue = template.tValue(part);

		// The value that is now set during re-do.
		Object newValue = toCurrent(rev, part, templateValue);

		if (newValue == null && templateValue != null || (newValue instanceof Collection<?> newCol
			&& templateValue instanceof Collection expCol && newCol.size() != expCol.size())) {

			Object missing = missing(rev, part, templateValue);

			// Some value can no longer be resolved.
			problems.add(I18NConstants.PROBLEM_OBJECTS_NO_LONGER_EXIST__OBJ_PART_MISSING_MERGED
				.fill(MetaLabelProvider.INSTANCE.getLabel(target),
					MetaLabelProvider.INSTANCE.getLabel(part),
					MetaLabelProvider.INSTANCE.getLabel(missing),
					MetaLabelProvider.INSTANCE.getLabel(newValue)));
		}
		return newValue;
	}

	private Object toCurrent(long rev, TLStructuredTypePart part, Object value) {
		if (part.getModelKind() == ModelKind.REFERENCE) {
			TLReference ref = (TLReference) part;
			return switch (ref.getHistoryType()) {
				case CURRENT, MIXED -> {
					if (value instanceof Collection<?> coll) {
						Collection<TLObject> result =
							ref.isOrdered() || ref.isBag() ? new ArrayList<>(coll.size()) : new HashSet<>(coll.size());
						for (Object element : coll) {
							TLObject currentElement = toCurrent(rev, element);
							if (currentElement != null) {
								result.add(currentElement);
							}
						}
						yield result;
					} else {
						yield toCurrent(rev, value);
					}
				}
				case HISTORIC -> value;
			};
		} else {
			return value;
		}
	}

	private TLObject toCurrent(long rev, Object obj) {
		if (obj == null) {
			return null;
		}
		TLObject historic = (TLObject) obj;
		if (historic.tId().getHistoryContext() == rev) {
			return WrapperHistoryUtils.getCurrent(historic);
		} else {
			return historic;
		}
	}

	private Object missing(long rev, TLStructuredTypePart part, Object value) {
		if (part.getModelKind() == ModelKind.REFERENCE) {
			return switch (((TLReference) part).getHistoryType()) {
				case CURRENT, MIXED -> {
					if (value instanceof Collection<?> coll) {
						List<Object> result = new ArrayList<>(coll.size());
						for (Object element : coll) {
							TLObject currentElement = toCurrent(rev, element);
							if (currentElement == null) {
								result.add(element);
							}
						}
						yield result;
					} else {
						TLObject current = toCurrent(rev, value);
						yield current == null ? value : null;
					}
				}
				case HISTORIC -> null;
			};
		} else {
			return null;
		}
	}

	private ResKey revert(ResKey message) {
		if (I18NConstants.REDO__MSG.getKey().equals(message.getKey())) {
			return I18NConstants.REVERTED__MSG.fill(firstArg(message));
		} else if (I18NConstants.REVERTED__MSG.getKey().equals(message.getKey())) {
			return I18NConstants.REDO__MSG.fill(firstArg(message));
		} else {
			return I18NConstants.REVERTED__MSG.fill(message);
		}
	}

	private Object firstArg(ResKey message) {
		Object[] arguments = message.arguments();
		return arguments.length > 0 ? arguments[0] : message;
	}

}
