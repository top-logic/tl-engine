<h2>Syntax</h2>

<pre>
	<code>$list.indexBy($key-fun)

$list.indexBy($key-fun, $clash-fun)

$list.indexBy($key-fun, $map-fun)

$list.indexBy($key-fun, $clash-fun, $map-fun)</code>
</pre>

<h2>Beschreibung</h2>

<p>Weist jedem Wert der Liste einen Schlüsselwert hinzu.</p>

<p>Im Gegensatz zur <a class="tlObject" data-custom="false" href="?page=groupBy&amp;uuid=0ceea055-4867-461a-9a86-d6ed56272dd8">Gruppierung</a> sind die Werte im resultierenden Wörterbuch keine Listen, sondern Einzelelemente. Daher müssen die berechneten Schlüsselwerte für die Elemente der Eingabemenge eindeutig sein. Über die Angabe einer optionalen <code class="hljs inlineCode">clash-fun</code> können Schlüsselkonflikte aufgelöst werden. Zusätzlich kann durch Angabe einer <code class="hljs inlineCode">map-fun</code> bestimmt werden, welcher Wert für jeden Schlüssel im resultierenden Wörterbuch gespeichert wird.</p>

<h2>Parameter</h2>

<table class="tlDocTable">
	<thead>
		<tr>
			<th>Name</th>
			<th>Typ</th>
			<th>Beschreibung</th>
			<th>Pflicht</th>
			<th>Default</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>list</td>
			<td>Menge</td>
			<td>Eine Liste, die indiziert werden soll.</td>
			<td>ja</td>
			<td> </td>
		</tr>
		<tr>
			<td>keyFun</td>
			<td>Funktion</td>
			<td>Schlüsselfunktion, nach der die Indizes erzeigt werden sollen.</td>
			<td>ja</td>
			<td> </td>
		</tr>
		<tr>
			<td>clashFun</td>
			<td>Funktion</td>
			<td>Clashfunktion, nach der Key-Duplikate aufgelöst werden können. Ohne diese Funktion erzeugen Duplikate Fehlermeldungen.</td>
			<td>nein</td>
			<td>Keine Auflösung von Duplikaten.</td>
		</tr>
		<tr>
			<td>mapFun</td>
			<td>Funktion</td>
			<td>Mapfunktion, welche die in der Liste gespeicherten Werte transformiert. Nimmt einen Parameter (das Listenelement) und gibt den zu speichernden Wert zurück.</td>
			<td>nein</td>
			<td>Originalwerte werden gespeichert.</td>
		</tr>
	</tbody>
</table>

<h2>Rückgabewert</h2>

<p><span style="color:#3498db"><strong>Typ:</strong></span> Fachobjekt</p>

<p>Ein Wörterbuch, in dem alle Werte der Liste einem Index zugeordnet sind.</p>

<h2>Beispiele</h2>

<h3>Indizierung nach Namenskürzel</h3>

<pre>
	<code>list("Smith Joe", "Parker Jane", "Taylor Tom", "Black Tyler", "Brown Erik")
   .indexBy(name -&gt; $name.subString(0, 3))</code>
</pre>

<p><strong>Ausgabe:</strong> Ein Wörterbuch mit den Werten:</p>

<pre>
<code>{
   "Smi":  "Smith Joe",
   "Par":  "Parker Jane",
   "Tay":  "Taylor Tom", 
   "Bla":  "Black Tyler",
   "Bro":  "Brown Erik"
}</code></pre>

<p>Aus jedem Namen werden die ersten 3 Buchstaben als Index verwendet.</p>

<h3>Indizierung nach Namenskürzel mit Clash-Funktion</h3>

<pre>
	<code>list("Smith Joe", "Parker Jane", "Brown Erik", "Taylor Tom", "Black Tyler", "Brook Ashley", "Browning Dave")
   .indexBy(name -&gt; $name.subString(0, 3), name1 -&gt; name2 -&gt; $name1 + " and " + $name2)
</code>
</pre>

<p><strong>Ausgabe:</strong> Ein Wörterbuch mit den Werten:</p>

<pre>
<code>{
   "Smi":  "Smith Joe",
   "Par":  "Parker Jane",
   "Tay":  "Taylor Tom", 
   "Bla":  "Black Tyler",
   "Bro":  "Brown Erik and Brook Ashley and Browning Dave"
}</code></pre>

<p>​Die drei Namen "Brown Erik", "Brook Ashley", "Browning Dave" erhalten durch die Schlüsselfunktion dieselben Schlüssel. Ohne Clashfunktion würde eine Fehlermeldung herauskommen. In diesem Fall werden die Namen für den Key zusammengesetzt.</p>

<h3>​Indizierung nach Namenskürzel mit Clash-Funktion und Map-Funktion</h3>

<pre>
<code>list("Smith Joe 45", "Parker Jane 32", "Brown Erik 28", "Taylor Tom 41", "Black Tyler 35", "Brook Ashley 29", "Browning Dave 33")
   .indexBy(
       name -&gt; $name.subString(0, 3), 
       age1 -&gt; age2 -&gt; ($age1 + $age2) / 2,
       name -&gt; numberFormat("#").parse($name.subString($name.length() - 2))
   )</code></pre>

<p><strong>Ausgabe:</strong> Ein Wörterbuch mit den Werten:</p>

<pre>
<code>{
   "Smi": 45.0,
   "Par": 32.0,
   "Tay": 41.0, 
   "Bla": 35.0,
   "Bro": 30.0
}</code></pre>

<p>Die Namen werden nach den ersten 3 Buchstaben indiziert. Aus jedem Namen werden die letzten 2 Zeichen (das Alter) extrahiert und mit <code class="bg-text-200/5 border border-0.5 border-border-300 text-danger-000 whitespace-pre-wrap rounded-[0.4rem] px-1 py-px text-[0.9rem]">numberFormat("#").parse()</code> als Zahl gespeichert (mapFun). Bei den drei Namen mit dem Präfix "Bro" wird das Durchschnittsalter berechnet: (28 + 29 + 33) / 2 = 30.</p>
