/*
 * SPDX-FileCopyrightText: 2016 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package com.top_logic.element.model.generate;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

import com.top_logic.basic.NamedComparator;
import com.top_logic.basic.generate.JavaGenerator;
import com.top_logic.element.config.annotation.TLSingletons;
import com.top_logic.model.ModelKind;
import com.top_logic.model.TLClass;
import com.top_logic.model.TLModel;
import com.top_logic.model.TLModule;
import com.top_logic.model.TLNamedPart;
import com.top_logic.model.TLType;
import com.top_logic.model.util.TLModelUtil;

/**
 * Super class for java class generators that create classes for parts of the {@link TLModel}.
 * 
 * @author <a href="mailto:daniel.busche@top-logic.com">Daniel Busche</a>
 */
public abstract class TLModelGenerator extends JavaGenerator {

	private boolean _noElementClasses = false;

	/**
	 * Creates a new {@link TLModelGenerator}.
	 * 
	 * @param packageName
	 *        See {@link JavaGenerator#JavaGenerator(String)}
	 */
	public TLModelGenerator(String packageName) {
		super(packageName);
	}

	/**
	 * Sorts the given {@link TLNamedPart} by name to have a stable order.
	 * 
	 * @param parts
	 *        The parts to sort.
	 * @return A {@link Collection} which {@link Collection#iterator()} returns the content of the
	 *         given parts in "name order".
	 */
	protected <T extends TLNamedPart> Collection<T> sort(Collection<T> parts) {
		switch (parts.size()) {
			case 0:
			case 1:
				return parts;
			default:
				ArrayList<T> sortedParts = new ArrayList<>(parts);
				Collections.sort(sortedParts, NamedComparator.INSTANCE);
				return sortedParts;
		}
	}

	/**
	 * Gets the simple class name for the fully qualified class name.
	 * 
	 * @param qualifiedClass
	 *        Fully qualified name of a Top-Level class. Especially names of inner or anonymous
	 *        classes are not allowed.
	 */
	protected static String simpleClassName(String qualifiedClass) {
		int lastDot = qualifiedClass.lastIndexOf('.');
		if (lastDot == -1) {
			// Qualified class is actually not qualified.
			return qualifiedClass;
		}
		return qualifiedClass.substring(lastDot + 1, qualifiedClass.length());
	}

	/**
	 * Gets the package name for the fully qualified class name.
	 * 
	 * @param qualifiedClass
	 *        Fully qualified name of a Top-Level class. Especially names of inner or anonymous
	 *        classes are not allowed.
	 */
	protected static String packageName(String qualifiedClass) {
		int lastDot = qualifiedClass.lastIndexOf('.');
		if (lastDot == -1) {
			// Qualified class is actually not qualified.
			return "";
		}
		return qualifiedClass.substring(0, lastDot);
	}

	/**
	 * Returns either the given qualified class name, or the simple class name if the class has the
	 * same package as this {@link TLModelGenerator#packageName() generator}.
	 * 
	 * @param qualifiedClass
	 *        Fully qualified name of a Top-Level class. Especially names of inner or anonymous
	 *        classes are not allowed.
	 */
	protected String dropPackage(String qualifiedClass) {
		String ownPackage = packageName();
		int ownPackageLength = ownPackage.length();
		if (qualifiedClass.startsWith(ownPackage) && qualifiedClass.length() > ownPackageLength
				&& qualifiedClass.charAt(ownPackageLength) == '.'
				&& qualifiedClass.indexOf('.', ownPackageLength + 1) < 0) {
			return qualifiedClass.substring(ownPackageLength + 1);
		} else {
			// Different package
			return qualifiedClass;
		}
	}

	/**
	 * Whether the given {@link TLModule} represents a structure.
	 */
	protected boolean isStructure(TLModule module) {
		return module.getAnnotation(TLSingletons.class) != null;
	}

	/**
	 * Whether the given {@link TLType} represents a built-in structure type.
	 */
	protected boolean isStructure(TLType type) {
		if (type.getModelKind() != ModelKind.CLASS) {
			return false;
		}

		TLType structureType = TLModelUtil.findType(type.getModel(), "tl.element:StructuredElement");
		if (structureType == null) {
			return false;
		}

		return TLModelUtil.isGeneralization((TLClass) structureType, (TLClass) type);
	}

	@Override
	protected void writeAuthor() {
		if (noElementClasses()) {
			line(" * @author Automatically generated by \"" + this.getClass().getName().replace('$', '.') + "\"");
		} else {
			super.writeAuthor();
		}
	}

	/**
	 * Whether generated classes must not depend on classes from {@link com.top_logic.element}.
	 */
	public boolean noElementClasses() {
		return _noElementClasses;
	}

	/**
	 * Setter for {@link #noElementClasses()}.
	 */
	public void setNoElementClasses(boolean noElementClasses) {
		_noElementClasses = noElementClasses;

	}

	/**
	 * Check that classes from element are allowed.
	 * 
	 * @implNote This method is designed to be called when files are created for classes in modules
	 *           that are structured.
	 * 
	 * @throws IllegalStateException
	 *         When {@link #noElementClasses() no element classes} are allowed.
	 * 
	 */
	protected void checkElementClassesAllowedInStructures() {
		if (noElementClasses()) {
			throw new IllegalStateException("Can not create classes for " + className()
				+ " because no element classes can be used, but module is a structure.");
		}
	}

}

