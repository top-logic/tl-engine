/*
 * SPDX-FileCopyrightText: 2001 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package com.top_logic.element.layout.structured;

import java.util.Map;
import java.util.Optional;

import com.top_logic.base.bus.MonitorEvent;
import com.top_logic.basic.config.InstantiationContext;
import com.top_logic.basic.config.annotation.defaults.BooleanDefault;
import com.top_logic.basic.config.annotation.defaults.FormattedDefault;
import com.top_logic.basic.util.ResKey;
import com.top_logic.element.core.util.ElementEventUtil;
import com.top_logic.element.structured.StructuredElement;
import com.top_logic.knowledge.service.KBUtils;
import com.top_logic.layout.form.component.AbstractDeleteCommandHandler;
import com.top_logic.mig.html.layout.LayoutComponent;
import com.top_logic.tool.boundsec.BoundCommand;
import com.top_logic.tool.boundsec.CommandGroupReference;
import com.top_logic.tool.boundsec.simple.SimpleBoundCommandGroup;
import com.top_logic.util.error.TopLogicException;

/**
 * Handler for removing an element.
 * 
 * The remove will only be performed, if the removing is allowed by the
 * element itself.
 * 
 * @author     <a href="mailto:mga@top-logic.com">Michael Gänsler</a>
 */
public class StructuredElementRemoveHandler extends AbstractDeleteCommandHandler {

	/** Config interface for {@link StructuredElementRemoveHandler}. */
	public interface Config extends AbstractDeleteCommandHandler.Config {

		@Override
		@BooleanDefault(BoundCommand.NEEDS_CONFIRM)
		boolean getConfirm();

		@Override
		@FormattedDefault(SimpleBoundCommandGroup.DELETE_NAME)
		CommandGroupReference getGroup();

	}

    /** The unique ID of this handler. */
    public static final String COMMAND = "elementRemove";

    public StructuredElementRemoveHandler(InstantiationContext context, Config config) {
		super(context, config);
    }

    @Override
	protected void deleteObject(LayoutComponent component, Object model,
			Map<String, Object> arguments) {
		checkStructuredElement(model);

		StructuredElement element = (StructuredElement) model;
		checkNoVeto(element);

		sendEvent(element);

		element.tDelete();
	}

	@Override
	protected void deleteObjects(LayoutComponent component, Iterable<?> elements, Map<String, Object> arguments) {
		elements.forEach(element -> {
			checkStructuredElement(element);
			checkNoVeto((StructuredElement) element);
		});

		@SuppressWarnings("unchecked")
		Iterable<? extends StructuredElement> items = (Iterable<? extends StructuredElement>) elements;
		sendEvents(items);

		KBUtils.deleteAll(items);
	}

	private void checkNoVeto(StructuredElement element) {
		Optional<ResKey> veto = element.tDeleteVeto();
		if (veto.isPresent()) {
			throw new TopLogicException(veto.get());
		}
	}

	private void checkStructuredElement(Object model) {
		if (!(model instanceof StructuredElement)) {
			throw new TopLogicException(I18NConstants.ERROR_NOT_A_STRUCTURED_ELEMENT__ELEMENT.fill(model));
        }
	}

    /**
     * Hook for subclasses. This method sends a MonitorEvent on the ModelTrackinUtil.
     * Overwrite this method if you want to deactivate or send special MonitorEvents.
     * Use this method if you want to generate MonitorEvents outside a GUI-Context.
     * MonitorEvents are generated by default. 
     * 
     * @param anElement the deleted element (before KB.commit())
     */
    public void sendEvent(StructuredElement anElement) {
        ElementEventUtil.sendEvent(anElement, MonitorEvent.DELETED);
    }
    
	/**
	 * Hook for subclasses. This method sends a {@link MonitorEvent} for each given
	 * {@link StructuredElement}.
	 * 
	 * @see #sendEvent(StructuredElement)
	 */
	public void sendEvents(Iterable<? extends StructuredElement> elements) {
		elements.forEach(this::sendEvent);
	}

}
