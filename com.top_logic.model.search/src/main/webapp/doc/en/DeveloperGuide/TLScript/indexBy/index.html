<h2>Syntax</h2>

<pre>
	<code>$list.indexBy($keyFun, $clashFun, $mapFun)</code>
</pre>

<h2>Description</h2>

<p>Assigns a key value to each value in the list.</p>

<p>In contrast to <a class="tlObject" data-custom="false" href="?page=groupBy&amp;uuid=0ceea055-4867-461a-9a86-d6ed56272dd8">grouping</a>, the values in the resulting dictionary are not lists, but individual elements. Therefore, the calculated key values must be unique for the elements of the input set. Key conflicts can be resolved by specifying an optional <code class="hljs inlineCode">clashFun</code>. You can also specify <code class="hljs inlineCode">mapFun</code> to determine which value is saved for each key in the resulting dictionary.</p>

<h2>Parameters</h2>

<table class="tlDocTable">
	<thead>
		<tr>
			<th>Key name</th>
			<th>Type</th>
			<th>Type Description</th>
			<th>Mandatory</th>
			<th>Default</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>list</td>
			<td>Quantity</td>
			<td>A list that is to be indexed.</td>
			<td>yes</td>
			<td> </td>
		</tr>
		<tr>
			<td>keyFun</td>
			<td>Function</td>
			<td>Key function according to which the indices are to be generated.</td>
			<td>yes</td>
			<td> </td>
		</tr>
		<tr>
			<td>clashFun</td>
			<td>function</td>
			<td>Clash function according to which key duplicates can be resolved. Without this function, duplicates generate error messages. If a mapFun is also specified, the mapped values are obtained, not the original entries from the list.</td>
			<td>no</td>
			<td>No resolution of duplicates.</td>
		</tr>
		<tr>
			<td>mapFun</td>
			<td>function</td>
			<td>Map function that transforms the values stored in the list. Takes a parameter (the list element) and returns the value to be saved. The transformation takes place after the key calculation has been completed.</td>
			<td>no</td>
			<td>Original values are saved.</td>
		</tr>
	</tbody>
</table>

<h2>Return value</h2>

<p><span style="color:#3498db"><strong>Type:</strong></span> Specialized object</p>

<p>A dictionary in which all values in the list are assigned to an index.</p>

<h2>Examples</h2>

<h3>Indexing by name abbreviation</h3>

<pre>
	<code>list("Smith Joe", "Parker Jane", "Taylor Tom", "Black Tyler", "Brown Erik")
   .indexBy(keyFun: name -&gt; $name.subString(0, 3))</code>
</pre>

<p><strong>Output:</strong> A dictionary with the values:</p>

<pre>
<code>{
   "Smi":  "Smith Joe",
   "Par":  "Parker Jane",
   "Tay":  "Taylor Tom", 
   "Bla":  "Black Tyler",
   "Bro":  "Brown Erik"
}</code></pre>

<p>The first 3 letters of each name are used as an index.</p>

<h3>Indexing by name abbreviation with clash function</h3>

<pre>
	<code>list("Smith Joe", "Parker Jane", "Brown Erik", "Taylor Tom", "Black Tyler", "Brook Ashley", "Browning Dave")
   .indexBy(keyFun: name -&gt; $name.subString(0, 3), clashFun: name1 -&gt; name2 -&gt; $name1 + " and " + $name2)
</code>
</pre>

<p><strong>Output:</strong> A dictionary with the values:</p>

<pre>
<code>{
   "Smi":  "Smith Joe",
   "Par":  "Parker Jane",
   "Tay":  "Taylor Tom", 
   "Bla":  "Black Tyler",
   "Bro":  "Brown Erik and Brook Ashley and Browning Dave"
}</code></pre>

<p>The three names "Brown Erik", "Brook Ashley", "Browning Dave" are given the same keys by the key function. Without the clash function, an error message would be displayed. In this case, the names are combined for the key.</p>

<h3>Indexing by name abbreviation with clash function and map function</h3>

<pre>
<code>[{"name": "Smith", "age": 45},
 {"name": "Parker", "age": 32},
 {"name": "Brown", "age": 28},
 {"name": "Brown", "age": 35},
 {"name": "Brown", "age": 33},
 {"name": "Taylor", "age": 41}
].indexBy(
    keyFun: person -&gt; $person["name"],
    clashFun: age1 -&gt; age2 -&gt; ($age1 + $age2) / 2,
    mapFun: person -&gt; $person["age"]
)</code></pre>

<p><strong>Output:</strong> A dictionary with the values:</p>

<pre>
<code>{Smith=45.0, Parker=32.0, Brown=32.25, Taylor=41.0}</code></pre>

<p>The names are used as keys. The age is extracted from each person object and saved as a value (mapFun). If several persons have the same name, the ages are averaged in pairs (clashFun).</p>
