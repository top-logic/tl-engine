<h2>Syntax</h2>

<pre>
	<code>$list.indexBy($keyFun, $clashFun, $mapFun)</code>
</pre>

<h2>Beschreibung</h2>

<p>Weist jedem Wert der Liste einen Schlüsselwert hinzu.</p>

<p>Im Gegensatz zur <a class="tlObject" data-custom="false" href="?page=groupBy&amp;uuid=0ceea055-4867-461a-9a86-d6ed56272dd8">Gruppierung</a> sind die Werte im resultierenden Wörterbuch keine Listen, sondern Einzelelemente. Daher müssen die berechneten Schlüsselwerte für die Elemente der Eingabemenge eindeutig sein. Über die Angabe einer optionalen <code class="hljs inlineCode">clashFun</code> können Schlüsselkonflikte aufgelöst werden. Zusätzlich kann durch Angabe einer <code class="hljs inlineCode">mapFun</code> bestimmt werden, welcher Wert für jeden Schlüssel im resultierenden Wörterbuch gespeichert wird.</p>

<h2>Parameter</h2>

<table class="tlDocTable">
	<thead>
		<tr>
			<th>Name</th>
			<th>Typ</th>
			<th>Beschreibung</th>
			<th>Pflicht</th>
			<th>Default</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>list</td>
			<td>Menge</td>
			<td>Eine Liste, die indiziert werden soll.</td>
			<td>ja</td>
			<td> </td>
		</tr>
		<tr>
			<td>keyFun</td>
			<td>Funktion</td>
			<td>Schlüsselfunktion, nach der die Indizes erzeugt werden sollen.</td>
			<td>ja</td>
			<td> </td>
		</tr>
		<tr>
			<td>clashFun</td>
			<td>Funktion</td>
			<td>Clashfunktion, nach der Key-Duplikate aufgelöst werden können. Ohne diese Funktion erzeugen Duplikate Fehlermeldungen. Wenn auch eine mapFun angegeben ist, erhält man die gemappten Werte, nicht die Originaleinträge aus der Liste.</td>
			<td>nein</td>
			<td>Keine Auflösung von Duplikaten.</td>
		</tr>
		<tr>
			<td>mapFun</td>
			<td>Funktion</td>
			<td>Mapfunktion, welche die in der Liste gespeicherten Werte transformiert. Nimmt einen Parameter (das Listenelement) und gibt den zu speichernden Wert zurück. Die Transformation findet statt, nachdem die Schlüsselberechnung abgeschlossen ist.</td>
			<td>nein</td>
			<td>Originalwerte werden gespeichert.</td>
		</tr>
	</tbody>
</table>

<h2>Rückgabewert</h2>

<p><span style="color:#3498db"><strong>Typ:</strong></span> Fachobjekt</p>

<p>Ein Wörterbuch, in dem alle Werte der Liste einem Index zugeordnet sind.</p>

<h2>Beispiele</h2>

<h3>Indizierung nach Namenskürzel</h3>

<pre>
	<code>list("Smith Joe", "Parker Jane", "Taylor Tom", "Black Tyler", "Brown Erik")
   .indexBy(keyFun: name -&gt; $name.subString(0, 3))</code>
</pre>

<p><strong>Ausgabe:</strong> Ein Wörterbuch mit den Werten:</p>

<pre>
<code>{
   "Smi":  "Smith Joe",
   "Par":  "Parker Jane",
   "Tay":  "Taylor Tom", 
   "Bla":  "Black Tyler",
   "Bro":  "Brown Erik"
}</code></pre>

<p>Aus jedem Namen werden die ersten 3 Buchstaben als Index verwendet.</p>

<h3>Indizierung nach Namenskürzel mit Clash-Funktion</h3>

<pre>
	<code>list("Smith Joe", "Parker Jane", "Brown Erik", "Taylor Tom", "Black Tyler", "Brook Ashley", "Browning Dave")
   .indexBy(keyFun: name -&gt; $name.subString(0, 3), clashFun: name1 -&gt; name2 -&gt; $name1 + " and " + $name2)
</code>
</pre>

<p><strong>Ausgabe:</strong> Ein Wörterbuch mit den Werten:</p>

<pre>
<code>{
   "Smi":  "Smith Joe",
   "Par":  "Parker Jane",
   "Tay":  "Taylor Tom", 
   "Bla":  "Black Tyler",
   "Bro":  "Brown Erik and Brook Ashley and Browning Dave"
}</code></pre>

<p>​Die drei Namen "Brown Erik", "Brook Ashley", "Browning Dave" erhalten durch die Schlüsselfunktion dieselben Schlüssel. Ohne Clashfunktion würde eine Fehlermeldung herauskommen. In diesem Fall werden die Namen für den Key zusammengesetzt.</p>

<h3>​Indizierung nach Namenskürzel mit Clash-Funktion und Map-Funktion</h3>

<pre>
<code>[{"name": "Smith", "age": 45},
 {"name": "Parker", "age": 32},
 {"name": "Brown", "age": 28},
 {"name": "Brown", "age": 35},
 {"name": "Brown", "age": 33},
 {"name": "Taylor", "age": 41}
].indexBy(
    keyFun: person -&gt; $person["name"],
    clashFun: age1 -&gt; age2 -&gt; ($age1 + $age2) / 2,
    mapFun: person -&gt; $person["age"]
)</code></pre>

<p><strong>Ausgabe:</strong> Ein Wörterbuch mit den Werten:</p>

<pre>
<code>{Smith=45.0, Parker=32.0, Brown=32.25, Taylor=41.0}</code></pre>

<p>Die Namen werden als Schlüssel verwendet. Aus jedem Personen-Objekt wird das Alter extrahiert und als Wert gespeichert (mapFun). Falls mehrere Personen denselben Namen haben, werden die Alter paarweise gemittelt (clashFun).</p>
